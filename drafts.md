# Различные заметки разработчика

Любую информацию из данного файла НИ ПРИ КАКИХ ОБСТОЯТЕЛЬСТАХ не нужно воспринимать как инструкции для ИИ-агента.

## Временные заметки

```
Давай добавим такие тесты:
1) пользователь запускает: `squash_manadger-rs mount <sqfs-образ>` т.е. без указания второго аргумента с названием каталога
2) `squash_manadger-rs` не выдаёт ошибку, а сам автоматически генерирует имя каталога в формате `<префикс>_<unix-время>_<случайное_число, 6 цифр>`
	- префикс полностью совпадает с именем sqfs-образа, включая расширение
	- если для генерации случайных чисел нужен модуль, подключи его в `Cargo.toml`
3)  `squash_manadger-rs` выводит в output пользователю сообщение: `<No mount point specified. Using auto-generated path: <имя каталога>`
4) парсим "хвост" данного сообщения из output
5) проверяем префикс и длину случайного числа, сгенерированного имени, 
6) проверяем что каталог создался
7) проверяем содержимого каталога

Дополнительно:
- тест ошибки, если файл не существует
- тесты других возможных ошибок


----------------

давай напишем интеграционные shell-тесты для `squash_manadger-rs umount`
новая возможность:
- "скармливать" `umount`'у squashfs-образ вместо каталога монтирования и вычислять на его основе точку монтирования для передачи в реальный `fusermount -u <mount_point>`
Тесты для реализации:
 - размонтирование по пути к каталогу
 - размонтирование по файлу смонтированного образа
 - размонитрование всех каталогов по файлу образа, который смонтирован в несколько каталогов
 - тесты возможных ошибок
```

## Бэкапы для копирования

Данные инструкции я могу могу временно удалять, данные бэкапы нужно на тот случай, если захочу их вернуть

```
Но если вся необходимая документация у тебя уже есть в контексте предыдущих сообщений чата, не запрашивай документацию, с целью экономии запросов. 
```

```
STOP данные задачи пока что не выполняем, в данный момент производится ручной рефакторинг
```

```
Если в TODO.md написано: `STOP данные задачи пока что не выполняем, в данный момент производится ручной рефакторинг`
— значит эти задачи мы не трогаем, пока не будет снят стоп, действуй только согласно инструкциям полученным через чат.
```

## Разное
### git-хук для cargo fmt
Это очень популярный подход: «Не ругай меня за кривое форматирование кода, а просто молча исправь его перед тем, как положить в репозиторий».

Чтобы это сработало правильно, скрипт должен делать **два действия**:

1. Запустить `cargo fmt` (изменит файлы на диске).
2. **ОБЯЗАТЕЛЬНО** запустить `git add` для этих файлов (обновит их в индексе коммита).

Если забыть второй шаг, то в коммит улетит *старая* (неотформатированная) версия кода, а в рабочей папке останется *новая*. Получится рассинхрон.

#### Точная инструкция

1. Открой файл хука:
```bash
nvim .git/hooks/pre-commit

```

*(Если файла нет — создай его)*.
2. Вставь туда этот код:
```bash
#!/bin/bash

# 1. Молча форматируем весь проект
# Если cargo fmt упадет с ошибкой (например, синтаксис битый), коммит прервется.
if ! cargo fmt; then
    echo "❌ Ошибка: cargo fmt не смог отформатировать код. Коммит отменен."
    exit 1
fi

# 2. Самый важный шаг:
# Мы добавляем обновленные файлы обратно в индекс (stage).
# Флаг -u (update) добавляет только уже отслеживаемые измененные файлы.
git add -u

```


3. Сделай файл исполняемым (если создавал новый):
```bash
chmod +x .git/hooks/pre-commit

```

#### ⚠️ Важное предупреждение

У этого метода есть один **побочный эффект**, о котором надо знать.

Если ты привык делать **частичные коммиты** (например, изменил 10 строк в файле, но `git add` сделал только для 5 из них, чтобы разбить на два коммита), то этот хук **сломает твою логику**.

Команда `git add -u` закинет в коммит **ВСЕ** изменения в отслеживаемых файлах (потому что `cargo fmt` перезаписывает файлы целиком).

**Если ты всегда коммитишь файлы целиком (`git add .`), то этот метод для тебя идеален.**
