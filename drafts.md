# Различные заметки разработчика

Любую информацию из данного файла НИ ПРИ КАКИХ ОБСТОЯТЕЛЬСТАХ не нужно воспринимать как инструкции для ИИ-агента.

## Бэкапы для копирования

Данные инструкции я могу могу временно удалять, данные бэкапы нужно на тот случай, если захочу их вернуть

```
Но если вся необходимая документация у тебя уже есть в контексте предыдущих сообщений чата, не запрашивай документацию, с целью экономии запросов. 
```

```
STOP данные задачи пока что не выполняем, в данный момент производится ручной рефакторинг
```

```
Если в TODO.md написано: `STOP данные задачи пока что не выполняем, в данный момент производится ручной рефакторинг`
— значит эти задачи мы не трогаем, пока не будет снят стоп, действуй только согласно инструкциям полученным через чат.
```

## Разное
### git-хук для cargo fmt
Это очень популярный подход: «Не ругай меня за кривое форматирование кода, а просто молча исправь его перед тем, как положить в репозиторий».

Чтобы это сработало правильно, скрипт должен делать **два действия**:

1. Запустить `cargo fmt` (изменит файлы на диске).
2. **ОБЯЗАТЕЛЬНО** запустить `git add` для этих файлов (обновит их в индексе коммита).

Если забыть второй шаг, то в коммит улетит *старая* (неотформатированная) версия кода, а в рабочей папке останется *новая*. Получится рассинхрон.

#### Точная инструкция

1. Открой файл хука:
```bash
nvim .git/hooks/pre-commit

```

*(Если файла нет — создай его)*.
2. Вставь туда этот код:
```bash
#!/bin/bash

# 1. Молча форматируем весь проект
# Если cargo fmt упадет с ошибкой (например, синтаксис битый), коммит прервется.
if ! cargo fmt; then
    echo "❌ Ошибка: cargo fmt не смог отформатировать код. Коммит отменен."
    exit 1
fi

# 2. Самый важный шаг:
# Мы добавляем обновленные файлы обратно в индекс (stage).
# Флаг -u (update) добавляет только уже отслеживаемые измененные файлы.
git add -u

```


3. Сделай файл исполняемым (если создавал новый):
```bash
chmod +x .git/hooks/pre-commit

```

#### ⚠️ Важное предупреждение

У этого метода есть один **побочный эффект**, о котором надо знать.

Если ты привык делать **частичные коммиты** (например, изменил 10 строк в файле, но `git add` сделал только для 5 из них, чтобы разбить на два коммита), то этот хук **сломает твою логику**.

Команда `git add -u` закинет в коммит **ВСЕ** изменения в отслеживаемых файлах (потому что `cargo fmt` перезаписывает файлы целиком).

**Если ты всегда коммитишь файлы целиком (`git add .`), то этот метод для тебя идеален.**
